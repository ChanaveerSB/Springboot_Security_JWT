package com.telusko.SpringSecurity.config;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationProvider;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.Customizer;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.crypto.password.NoOpPasswordEncoder;
import org.springframework.security.provisioning.InMemoryUserDetailsManager;
import org.springframework.security.web.SecurityFilterChain;


@Configuration
@EnableWebSecurity //don't go with default flow go with below flow
public class SecurityConfig {

    @Autowired
    private UserDetailsService userDetailsService;

    //bean for security filter chain
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {  //HttpSecurity gives SecurityFilterChain object
        //http.build() gives SecurityFilterChain
//        return http.build();

        //Adding Security Layers :

        //When we make our http stateless(NONE user data stored for any purpose like auto login)
        //Disables CSRF protection, usually done for REST APIs where CSRF tokens are not required (e.g., Postman/JWT).
//        http.csrf(customizer -> customizer.disable());

        //Ensures that every endpoint can be accessed only by authenticated users; no public URLs are allowed.
//        http.authorizeHttpRequests(request -> request.anyRequest().authenticated());

        //Enables default FORM-BASED login provided by Spring Security (auto login page, username/password authentication).
//        http.formLogin(Customizer.withDefaults());    //desable to avoid repeated login with each new request(Session Id)

        //Enables HTTP Basic authentication, where credentials are sent in the request header (commonly used for APIs and testing)
//        http.httpBasic(Customizer.withDefaults());

        //For every request u have to send Credentials (Username and password) for form login (not happening normal way in browser)
        //New Request means again login, So we have to send username password credentials along with each request(ie each new session due to Stateless)
        //so when login with credentials then submit request, then again login asking for credentials because each new request is new session so each time authentication
        //But works on Postman
        //SessionCreationPolicy.STATELESS → Spring Security does not create or rely on HTTP sessions, so it will not store any authentication information between requests.
        //Every request must send credentials (username/password or token) because the server treats each request as completely independent, with no memory of previous logins.
        //New session IDs may be generated by the server, but they are ignored; each request is authenticated independently.
        //Clarification: Even if a new session ID is created by the server, Spring Security does not use it for authentication — it’s just a servlet container artifact.
        //But works on Postman because it sends credentials each time along with each request, So content is visible, unlike browser where we repeatedly(infinite loop) give credentials as no credentials are sent with each request
//        http.sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS));

//        http.csrf(customizer -> customizer.disable());
//        http.authorizeHttpRequests(request -> request.anyRequest().authenticated());
//        http.formLogin(Customizer.withDefaults());    //disable to avoid repitative login with each new request(Session Id) switches to popup authentication
//        http.httpBasic(Customizer.withDefaults());
//        http.sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS));

//        return http.build();

                    //OR//

        return http
                .csrf(customizer -> customizer.disable()) // Disables CSRF protection (common for stateless APIs)
                .authorizeHttpRequests(request -> request.anyRequest().authenticated()) // Requires authentication for all requests
                .httpBasic(Customizer.withDefaults()) // Enables HTTP Basic authentication (credentials in headers)
                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .build();

//        formLogin(Customizer.withDefaults());    //disable to avoid repeated login with each new request(Session Id) switches to popup authentication (uname & pwd)

    }


    //Bean will be created in spring container and Spring security will pick it from there
    //This below bean is for to check(authenticate) user credentials among many users data, IN MY OWN NEW WAY, Not Default Way provided by spring security (ie to check with username and password provided in application.properties )
//    @Bean
//    public UserDetailsService userDetailsService(){
//        //UserDetailsService is Interface so we cannot return its object so we return its Implimentation class ie InMemoryDetailsManager();
//
//        UserDetails user1 = User
//                .withDefaultPasswordEncoder()   //Depricated due to old method to encode
//                .username("prem")
//                .password("p@123")
//                .roles("Admin")
//                .build();
//
//        UserDetails user2 = User
//                .withDefaultPasswordEncoder()   //Depricated due to old method to encode
//                .username("ravi")
//                .password("r@123")
//                .roles("User")
//                .build();
//
//        //Because InMemoryUserDetailsManager has 2 collections, One is collection of users and other is user objects args(i.e var args) to match it with collection of users
//        return new InMemoryUserDetailsManager(user1 , user2);   //this checks the credentials given in login with these user details
//    }   //these are hard coded values(users: user1, user2) , But we want this to connect with the Database, So comment it
    //Whenever user sends credentials its an (Un Authenticated)Authentication object to Authentication Provider(The authentication checking code/software provider)
    //Then the Authentication provider checks the (Un Authenticated object) and if it verifies then it is considered now as (Authenticated)Authentication Object
    //But we dont want to authenticate user with default authentication providers code rather we want our own way to Authenticate user
    //So we create our own Authentication Provider in below Bean

    //AuthenticationProvider is an INTERFACE
    @Bean
    public AuthenticationProvider authenticationProvider(UserDetailsService userDetailsService){
        //There are multiple AuthProvider and one of them is for DataBase and that is DaoAuthenticationProvider
        DaoAuthenticationProvider provider = new DaoAuthenticationProvider();     //(deprecated method) it will not work directly as This one needs to connect with the database (PostgreSQL)
        //Now we are using default password encoder
        provider.setPasswordEncoder(NoOpPasswordEncoder.getInstance());     //(deprecated method)
        //setting our own UserDetailService by Autowiring in second line below (current) SecurityConfig class
        provider.setUserDetailsService(userDetailsService);     //(deprecated method) (entity)class containing our own required user details to provide authentication service

        return provider;

    }
}
